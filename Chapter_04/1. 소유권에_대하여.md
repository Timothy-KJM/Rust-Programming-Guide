소유권에 대하여
===

### 소유권

* 소유권: RUST 프로그램의 메모리 관리법을 지배하는 규칙
    + 직접 명시적으로 메모리를 할당하고 해제하는 방식이 아니다.
    + 가비지 컬렉터를 이용한 해제 방식도 아니다.
* RUST는 소유권을 이용하여 메모리를 관리한다.
    + 이 규칙 중 하나라도 위반하면 프로그램은 컴파일되지 않는다.
    + 소유권은 프로그램의 실행 속도에 영향을 주지 않는다.
      
--------------------------------------------

### 스택과 힙 영역

* 스택
    + 후입선출(LIFO)
    + 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져있어야 한다.
* 힙
    + 과정
        1. 데이터를 힙에 저장할 때 공간이 있는지 OS에 확인한다.
        2. 메모리 할당자는 힙에서 빈 공간을 찾고 해당 지점의 포인터를 반환한다.
                  
* 스택 영역은 데이터에 접근하는 방식 상 힙 영역보다 속도가 빠르다.
    + 힙 영역은 포인터가 가리키는 곳을 찾아가는 과정으로 속도가 느리다.
                  
* 소유권은 힙 데이터와 관련이 있으며, 주요 목표가 힙 데이터의 관리이다.

--------------------------------------------

### 소유권 규칙

* RUST에서, 각각의 값은 소유자가 정해져 있다.
* 한 데이터의 소유자는 동시에 여럿이 존재할 수 없다.
* 소유자가 스코프 밖으로 벗어날 때, 데이터는 버려진다.

--------------------------------------------

### 변수의 스코프

* 스코프: 프로그램 내에서 아이템이 유효한 범위다.

```RUST
{                       // s는 아직 선언되지 않아서 여기서는 유효하지 않다.
    let s = "hello";    // 이 지점부터 s가 유효하다.
    ...                 // s로 어떤 작업을 한다.
}                       // 이 스코프가 종료되고, s가 더 이상 유효하지 않다.
```
--------------------------------------------

### String

소유권 규칙은 힙 데이터 관리가 목적이기 때문에 이를 공부하기 위한 적합한 타입이 필요하다. 그리고 이는 String 타입이 좋은 예시이다.

* 문자열 리터럴은 사용하기 편리하지만, 불변이다.
    + 사용자한테 문자열을 입력받아야 하는 경우 문자열 리터럴을 사용할 수 없다.
* RUST는 또 다른 문자열 타입인 String을 제공한다.
    + String은 힙에 할당된 데이터를 다루기 때문에, 컴파일 타임에 크기를 알 수 없는 텍스트도 저장할 수 있다.

```RUST
// String 이름공간에 있는 from()을 지정할 수 있게 ::를 사용한다.
let mut s = String::from("hello");
s.push_str(", world!");     // push_str()이 문자열에 리터럴을 추가한다.

println!("{}", s);          // 'hello, world!'를 출력한다.
```
--------------------------------------------

### 메모리와 할당

* 문자열 리터럴은 컴파일 타임에 내용을 알 수 있다.
    + 따라서, 텍스트가 최종 실행파일에 하드코딩된다.
    + 빠르고 효율적이지만, 문자열이 불변인 경우에만 사용할 수 있다.

* String은 힙에 메모리를 할당하는 방식을 사용한다.
    + 따라서, 런타임에 텍스트 내뇬 및 크기를 변경할 수 있다.
    + 이는 다음을 의미하기도 한다.
        - 실행 중 메모리 할당자에게 메모리를 요청해야 한다.
        - String을 사용하고 난 후 메모리를 해제할 방법이 필요하다.

* RUST는 메모리를 해제할 방법으로 제 3의 방법을 선택했다.
    + 변수가 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식이다.
    + 변수가 스코프 밖으로 벗어나면 drop이라는 특별한 함수를 호출한다.
        - 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있게 되어있다.
        - drop은 }가 나타나는 지점에서 자동으로 호출된다.
    + C++에서는 RAII 패턴으로 불리며, 이와 유사하다.
                 
```RUST
let x = 5;
let y = x;      // y에 x의 복사본을 만들어 바인딩한다.

let s1 = String::from("hello");
let s2 = s1;    // String 데이터만 복사되고, 힙의 데이터는 복사되지 않는다.
```
* s2, s1이 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 중복 해제가 된다.
    + 이는 메모리 안정성 버그이며, 보안을 취약하게 만드는 메모리 손상의 원인이다.
    + 따라서, let s2 = s1; 이후로는 s1이 더 이상 유효하지 않다고 판단한다.
                 
* 만약 힙 데이터까지 깊은 복사를 하고 싶을 때엔 clone이라는 메소드를 사용하면 된다.

```RUST
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```
--------------------------------------------

### 소유권과 함수

* 함수로 데이터를 전달하는 방식은 변수에 데이터를 대입할 때와 유사하다.
    - 함수에 변수를 전달하면 대입 연산과 마찬가지로 이동이나 복사가 일어난다.

```RUST
fn main()
{
    let s = String::from("hello");      // s가 스코프 내부로 들어온다.
    takes_ownership(s);                 // s의 데이터가 함수로 이동된다.
                                        // 여기서부터는 s가 유효하지 않다.
    
    let x = 5;                          // x가 스코프 내부로 들어온다.                  
    makes_copy(x);                      // x가 함수로 이동되지만, 
                                        // copy이므로 x를 계속 사용할 수 있다.
}   // 여기서 s와 x가 스코프 밖으로 벗어난다. 그러나 s의 데이터는 이동되어서 버려지지 않는다.

fn takes_ownership(some_string: String) // some_string이 스코프 내부로 들어온다.
{
    println!("{}", some_string);
}   // 여기서 some_string이 스코프 밖으로 벗어나고 drop이 호출되며 데이터가 버려진다.

fn makes_copy(some_integer: i32)        // some_integer가 스코프 내부로 들어온다.
{
    println!("{}", some_integer);
}   // 여기서 some_integer가 스코프 밖으로 벗어나지만 아무 일도 일어나지 않는다.
```
--------------------------------------------

### 반환값과 스코프

* 소유권은 값을 반환하는 과정에서 이동한다.

```RUST
fn main()
{
    let s1 = gives_ownership();         // gives_ownership이 자신의 반환값을
                                        // s1으로 이동시킨다.
    
    let s2 = String::from("hello");     // s2가 스코프 내부로 들어온다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back으로 이동되고,
                                        // 이 함수 또한 자신의 반환값을 s3로 이동시킨다.
}   // 여기서 s1, s3는 스코프 밖으로 벗어나며 버려지지만, s2는 이동되었다.

fn gives_ownership() -> String
{   // give_ownership()은 자신의 반환값을 자신의 호출자 함수로 이동시킬 것이다.
    let some_string = String::from("yours");    // some_string이 스코프 내부로 들어온다.
    some_string                                 // some_string이 호출자 함수로 이동한다.
}

fn takes_and_gives_back(a_string: String) -> String
{   // a_string이 스코프 내부로 들어온다.
    a_string                            // a_string이 반횐되고 호출자 함수로 이동한다.
}
```
--------------------------------------------

### 튜플 반환

* RUST에서는 tuple을 반환함으로써 여러 값을 리턴하는 것이 가능하다.

```RUST
fn main()
{
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize)
{
    let length = s.len();   // len()은 String의 길이를 반환한다.
    (s, length)
}
```